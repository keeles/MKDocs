{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introduction to EJS","text":"<p>Welcome to the fascinating world of EJS (Embedded JavaScript Templates), where the dynamic power of JavaScript meets the simplicity of HTML templates! Whether you're crafting a small project or architecting a large application, EJS offers a flexible and intuitive way to generate HTML markup with plain JavaScript.</p> <p>EJS is all about efficiency and ease of use. It lets you insert JavaScript values into your HTML and use JavaScript to iterate over data, conditionally display content, and include reusable templates. But what truly makes EJS shine is its customizable nature, brought to life through a wide array of options.</p> <p>It is commonly used with an Express server, something we will cover thoroughly in this documentation as we highly recommend this approach for first time users.</p> <ul> <li> <p>This documentation will walk you through the syntax, features, troubleshooting, and example of use with an Express server.</p> </li> <li> <p>If you are new to EJS be sure to read the prerequisite knowledge and software requirements in the section below. </p> </li> </ul>"},{"location":"#intended-users","title":"Intended Users","text":"<p>This documentation is targeted towards the following users:</p> <ul> <li>Beginner to intermediate web developers</li> <li>Individuals who are interested in creating their own web project</li> </ul>"},{"location":"#prerequisite-knowledge","title":"Prerequisite Knowledge","text":"<p>This guide necessitates the fulfillment of the following prerequisite:</p> <ul> <li>Foundational knowledge of Javascript, HTML, CSS</li> <li>Ability to execute commands in terminals</li> <li>Familiar with the express.js structure</li> <li>Familiar with the node.js environment including package installation using npm or yarn</li> </ul>"},{"location":"#software-requirement","title":"Software Requirement","text":"<p>Before we proceed, users should have the following installed on their machines:</p> <ul> <li><code>Node.js</code></li> <li><code>Any code editor (in our examples, we will use visual studio code)</code></li> <li><code>Express.js (optional)</code></li> </ul>"},{"location":"#procedure-overview","title":"Procedure Overview","text":"<ul> <li>Getting Started (Installation for all required software)</li> <li>EJS tags, include, general information</li> <li>Usage with Express.js</li> <li>Troubleshooting</li> <li>Glossary</li> </ul>"},{"location":"#notes-and-warning-messages","title":"Notes and Warning Messages","text":"<p>Throughout the documentation, we will use message blocks to alert you to relevant information.  Each possible message block, from most important to least important:</p> <p>Danger</p> <p>Specifies actions that may cause an error or will cause the application to crash.</p> <p>Warning</p> <p>Specifies content that must be read before proceeding.</p> <p>Info</p> <p>Indicates additional information or tips.</p> <p>Success</p> <p>Indicates what success looks like.</p> <p>For official documentation visit ejs.co.</p>"},{"location":"Express/express/","title":"EJS with Express","text":""},{"location":"Express/express/#this-guide-assumes-you-are-familiar-with-the-following-concepts","title":"This guide assumes you are familiar with the following concepts","text":"<ul> <li>You are comfortable writing Javascript and HTML</li> <li>You are familiar with Express.js <ul> <li>ExpressJS</li> </ul> </li> <li>Basic understanding of HTTP<ul> <li>HTTP</li> </ul> </li> </ul>"},{"location":"Express/express/#introduction","title":"Introduction","text":"<ul> <li>The purpose of this section is to introduce you to using EJS template engine with an express server to render dynamic HTML in the browser. We will set up a simple server with a home route and pass some data from our Javascript file to be displayed when the request is made. As mentioned above we are assuming that you already have a basic understanding of HTTP methods and how an express server is set up.</li> </ul>"},{"location":"Express/express/#using-ejs-templates-in-express","title":"Using EJS Templates in Express","text":"<p>1. Set up a basic express app     - We recommend copying the Hello World starter code from the express documentation here:         - Hello World in Express</p> <pre><code>const express = require('express')\nconst app = express()\nconst port = 3000\napp.get('/', (req, res) =&gt; {\n    res.send('Hello World!')\n})\napp.listen(port, () =&gt; {\nconsole.log(`Example app listening on port ${port}`)\n})\n</code></pre> <ul> <li>We recommend using nodemon to run your express server, but it is not necessary<ul> <li>Nodemon Documentation</li> </ul> </li> <li>Start your server to test everything is working correctly (Node .js or Nodemon .js)  <p>2. Set Up EJS file     - Set up your EJS file the same way you would for an HTML file, just use the extension .ejs instead of .html</p> <pre><code>&lt;!DOCTYPE html&gt;\n&lt;html lang=\"en\"&gt;\n\n&lt;head&gt;\n    &lt;meta charset=\"UTF-8\"&gt;\n    &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt;\n    &lt;title&gt;Example EJS&lt;/title&gt;\n&lt;/head&gt;\n\n&lt;body&gt;\n\n    &lt;h1&gt;Hello World&lt;/h1&gt;\n\n&lt;/body&gt;\n\n&lt;/html&gt;\n</code></pre> <ul> <li>Lets test that we can display this file using our express server 3. Next we need to change <code>res.send</code> to <code>res.render</code> and pass the filename we would like our server to render when the specified HTTP request is made</li> <li>In order to let express know which file extension to look for when sending responses, we set the <code>view engine</code> in our express server with the following line of code</li> </ul> <pre><code>app.set('view engine', 'ejs')\n</code></pre> <p>4. The view engine requires all of our ejs files to be put into a folder called 'views'     - Express will look into this folder to match the filename we pass into our <code>res.render</code> function     - You do not need to pass the file extension into <code>res.render</code> after setting the view engine</p> <pre><code>const express = require('express')\nconst app = express()\nconst port = 3000\n\napp.set('view engine', 'ejs')\n\napp.get('/', (req, res) =&gt; {\n    res.render('index')\n})\n\napp.listen(port, () =&gt; {\n    console.log(`Example app listening on port ${port}`)\n})\n</code></pre> <ul> <li>You should now see the heading Hello World if you go to localhost:3000 in your browser     </li> </ul>"},{"location":"Express/express/#rendering-dynamic-ejs","title":"Rendering Dynamic EJS","text":""},{"location":"Express/express/#passing-in-data","title":"Passing in Data","text":"<p>4. Let's pass in some data to be rendered in the browser - Inside our index.js file, let's make an array of people</p> <pre><code>const people = ['Aless', 'Christy', 'Kyle']\n</code></pre> <p>5. We can pass this data into our <code>res.render</code> function inside the second parameter     - The second parameter requires your variables to be inside a Javascript Object     - If your key is the same name as your variable, you do not need to specify the value</p> <pre><code>app.get('/', (req, res) =&gt; {\n    res.render('index',{ people })\n})\n</code></pre> <p>6. Inside of our ejs file, we can use the EJS tags to execute Javascript logic before the page is rendered     - Lets set up a simple loop to show all of the people in our array on the page</p> <pre><code>&lt;body&gt;\n    &lt;% for (const person of people) { %&gt;\n        &lt;h1&gt; Hello &lt;%= person %&gt; &lt;/h1&gt;  \n    &lt;% } %&gt;\n\n&lt;/body&gt;\n</code></pre> <p>7. Restart your server and refresh the page on the browser, you should now see the following on the page</p> <p></p> <ul> <li>If we take a look at the developer tools, we can see the HTML that was sent to the browser once our file was rendered </li> <li>As you can see, the login in our EJS file was executed, and the results were sent to the browser as plain HTML</li> </ul>"},{"location":"Express/express/#passing-in-multiple-variables","title":"Passing in Multiple Variables","text":"<ul> <li>You can pass in as many variables as you like into the <code>res.render</code> function</li> <li>Let's assume someone is logged in on your web app, and you want to display their name on the page, and a list of their friends</li> </ul> <p>8. Make the following changes to your index.js code</p> <pre><code>const express = require('express')\nconst app = express()\nconst port = 3000\n\napp.set('view engine', 'ejs')\n\nconst user = 'Sam'\nconst people = ['Aless', 'Christy', 'Kyle']\n\napp.get('/', (req, res) =&gt; {\n    res.render('index',{ friends: people, user })\n})\n\napp.listen(port, () =&gt; {\n    console.log(`Example app listening on port ${port}`)\n})\n</code></pre> <p>9. Update your EJS file by adding the following lines</p> <p><pre><code>&lt;!DOCTYPE html&gt;\n&lt;html lang=\"en\"&gt;\n\n&lt;head&gt;\n    &lt;meta charset=\"UTF-8\"&gt;\n    &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt;\n    &lt;title&gt;Example EJS&lt;/title&gt;\n&lt;/head&gt;\n\n&lt;body&gt;\n\n    &lt;h1&gt; Welcome &lt;%= user %&gt; &lt;/h1&gt;\n\n    &lt;h3&gt;List of friends&lt;/h3&gt;\n\n    &lt;ul&gt;\n        &lt;% for (const person of friends) { %&gt;\n            &lt;li&gt; &lt;%= person %&gt; &lt;/li&gt;  \n        &lt;% } %&gt;\n    &lt;/ul&gt;\n\n&lt;/body&gt;\n\n&lt;/html&gt;\n</code></pre> 10. Restart your server and refresh the page on the browser, you should now see the following on the page</p> <p></p> <p>Success</p> <p> Congratulations, you just built your first dynamic web app with Express and EJS!</p> <p>Great job \ud83e\udd17.</p>"},{"location":"Features/Features/","title":"Advanced Templating Features","text":"<p>EJS (Embedded JavaScript Templates) is a powerful templating engine that can revolutionize how you build dynamic websites. In this guide, we're going to explore a variety of options and features that EJS offers, enabling you to tailor it perfectly to your project's needs. From speeding up your rendering process with template caching to customizing your templating syntax with unique delimiters, this journey will unveil the full potential of EJS for your web development projects.</p> <p>Whether you're diving into EJS for the first time or you're a seasoned developer looking to enhance your existing projects, understanding the breadth of options available can open up new possibilities. We'll cover how to optimize performance, manage modular templates through includes, control the execution context, and even set up EJS for efficient client-side rendering. Let's embark on this explorative path together, unlocking advanced techniques to make your web development workflow more efficient and your templates more powerful.</p>"},{"location":"Features/Features/#options","title":"Options","text":"<p>Options in EJS act as customizable settings that dictate how your templates behave and render. These options range from performance optimizations like template caching to syntax adjustments for template delimiters. They can also influence the output's whitespace, ensuring your site's source code is clean and maintainable. Understanding and utilizing these options allows you to fine-tune your templating environment, whether you're aiming to enhance performance, ensure your templates are more readable, or need EJS to better fit within your existing development setup.</p>"},{"location":"Features/Features/#caching-compiled-functions","title":"Caching Compiled Functions","text":"<p>Caching is a critical performance feature in EJS, designed to eliminate redundant template compilation on every render. By enabling caching (<code>cache: true</code>) and assigning a unique <code>filename</code> for each template, EJS caches the compiled version, dramatically speeding up subsequent renders. This optimization is invaluable in production, where performance is paramount. Here's how you can enable caching:</p> <pre><code>ejs.renderFile('path/to/template.ejs', { title: 'EJS Caching Example' }, { cache: true, filename: 'template' }, function(err, html) {\n  if (err) {\n    console.error(err);\n  } else {\n    console.log(html);\n  }\n});\n</code></pre>"},{"location":"Features/Features/#including-subtemplates","title":"Including Subtemplates","text":"<p>To promote DRY principles and enhance template manageability, EJS facilitates the inclusion of subtemplates. This feature allows you to reuse template parts (like headers and footers) across different pages. Including a subtemplate is straightforward, using the `&lt;%- include('path/to/subtemplate', { someData: 'data' }) %&gt; syntax. For example, integrating a common header and footer could look like this:</p> <pre><code>&lt;%- include('partials/header', { title: 'My Website' }) %&gt;\n&lt;h1&gt;Welcome to My Website&lt;/h1&gt;\n&lt;p&gt;This is an example of including subtemplates.&lt;/p&gt;\n&lt;%- include('partials/footer') %&gt;\n</code></pre>"},{"location":"Features/Features/#custom-delimiters","title":"Custom Delimiters","text":"<p>EJS uses <code>&lt;%</code> and <code>%&gt;</code> as its default scriptlet tags, but you can customize these delimiters if they conflict with other template languages or if you prefer a different style. This is done by setting the <code>delimiter</code>, <code>openDelimiter</code>, and <code>closeDelimiter</code> options. Customizing delimiters can be particularly useful when integrating EJS with other systems where the default syntax might cause issues. For instance, if you wanted to use square brackets instead of angle brackets, you could configure EJS as follows:</p> <pre><code>ejs.render('[%= user.name %]', { user: { name: 'Alice' } }, { delimiter: '%' });\n</code></pre>"},{"location":"Features/Features/#debugging","title":"Debugging","text":"<p>EJS templates compile down to JavaScript functions, and sometimes it can be challenging to understand how your template translates into JavaScript, especially when errors occur. By setting the <code>debug</code> option to <code>true</code>, EJS will log the generated function body, giving you insight into the compilation process. This can be invaluable for debugging complex templates. However, it's best to use this feature during development only, as it can impact performance.</p> <pre><code>ejs.compile('template', { compileDebug: true });\n</code></pre>"},{"location":"Features/Features/#control-flow-output-escaping-and-comments","title":"Control Flow, Output Escaping, and Comments","text":"<p>EJS supports direct control flow statements (like <code>if</code>, <code>else</code>, <code>for</code>) within templates, enabling dynamic content rendering based on conditions. It also provides mechanisms for safely escaping output to prevent XSS attacks, using <code>&lt;%= %&gt;</code> for escaped output and <code>&lt;%- %&gt;</code> for raw output. Additionally, EJS supports comments via <code>&lt;%# %&gt;</code> tags, which can be useful for leaving notes or temporarily disabling parts of the template. Here's a combined example demonstrating these features: <pre><code>&lt;!--Inside your ejs file--&gt;\n&lt;%# This is a comment %&gt;\n&lt;% if (user) { %&gt;\n  &lt;h1&gt;Hello, &lt;%= user.name %&gt;&lt;/h1&gt;\n&lt;% } else { %&gt;\n  &lt;h1&gt;Hello, Guest&lt;/h1&gt;\n&lt;% } %&gt;\n</code></pre></p>"},{"location":"Features/Features/#include","title":"Include","text":"<p>In EJS, the <code>include</code> function streamlines web development by allowing for the insertion of reusable templates, such as user details, into a main template, thus adhering to the DRY principle. This modular approach facilitates easier maintenance and scalability of web applications. For instance, to display a list of users, you can loop through a users array and include a sub-template for each user, as shown below: <pre><code>&lt;ul&gt;\n  &lt;% users.forEach(user =&gt; &lt;%- include('user/show', { user }); %&gt;); %&gt;\n&lt;/ul&gt;\n</code></pre></p>"},{"location":"Features/Features/#cli","title":"CLI","text":"<p>EJS's command-line interface (CLI) brings the power of EJS templating to the terminal, providing a suite of options for rendering files directly from the command line. This feature is especially useful for batch processing, testing, or integrating EJS into scripts and other development workflows. The CLI supports a range of options that mirror those available in the JavaScript API, making it a versatile tool for developers familiar with EJS.</p>"},{"location":"Features/Features/#cache","title":"cache","text":"<p>The cache option enables the caching of compiled functions, significantly speeding up the rendering process for templates that are used frequently. This option requires the use of the filename parameter to uniquely identify each template in the cache, ensuring that templates are correctly retrieved from cache when needed.</p>"},{"location":"Features/Features/#-o-output-file-file","title":"-o / --output-file FILE","text":"<p>The <code>-o</code> or <code>--output-file</code> argument specifies a file to which the rendered output should be written. By default, EJS renders to stdout, which is suitable for viewing output directly in the terminal or piping to other commands. However, when rendering files as part of a build process or for static site generation, directing output to a specific file is often necessary.</p>"},{"location":"Features/Features/#-f-data-file-file","title":"-f / --data-file FILE","text":"<p>The <code>-f</code> or <code>--data-file</code> option allows you to specify a JSON-formatted file as the source of data for rendering the template. This feature is particularly useful when you have predefined data structures or are utilizing data from an external source, enabling dynamic content generation based on the contents of the file.</p>"},{"location":"Features/Features/#-i-data-input-string","title":"-i / --data-input STRING","text":"<p>Similar to the <code>-f</code> option, <code>-i</code> or <code>--data-input</code> accepts a JSON-formatted and URI-encoded string as input data for rendering. This option is ideal for passing small amounts of data directly through the command line without the need for an external file.</p>"},{"location":"Features/Features/#-m-delimiter-character","title":"-m / --delimiter CHARACTER","text":"<p>The <code>-m</code> or <code>--delimiter</code> argument allows you to customize the character used for opening and closing tags within your EJS templates. By default, EJS uses % as the delimiter, but this can be changed to any character that suits your project's needs, providing flexibility in template syntax.</p>"},{"location":"Features/Features/#-p-open-delimiter-character","title":"-p / --open-delimiter CHARACTER","text":"<p>With <code>-p</code> or <code>--open-delimiter</code>, you can define a custom character to replace the standard left angle bracket (&lt;) for opening EJS tags. This option is useful when integrating EJS templates with other languages or systems where the default syntax may cause conflicts.</p>"},{"location":"Features/Features/#-c-close-delimiter-character","title":"-c / --close-delimiter CHARACTER","text":"<p>The <code>-c</code> or <code>--close-delimiter</code> option serves a similar purpose to -p, but for the closing tag, allowing you to specify a custom character to replace the right angle bracket (&gt;) for closing EJS tags. This customization ensures compatibility across different environments and syntax requirements.</p>"},{"location":"Features/Features/#-s-strict","title":"-s / --strict","text":"<p>Enabling the <code>-s</code> or <code>--strict</code> mode forces the generated functions to run in JavaScript's strict mode. This mode imposes stricter parsing and error handling on your code, helping to prevent common coding bloopers and making it easier to write \"secure\" JavaScript.</p>"},{"location":"Features/Features/#-n-no-with","title":"-n / --no-with","text":"<p>The <code>-n</code> or <code>--no-with</code> option disables the use of JavaScript's with statement in the template's scope. This leads to better performance and more predictable scope resolution, with variables explicitly taken from the locals object. This option implicitly enables strict mode (--strict).</p>"},{"location":"Features/Features/#-l-locals-name","title":"-l / --locals-name","text":"<p>With <code>-l</code> or <code>--locals-name</code>, you can specify the name of the object that stores local variables in templates when not using the with statement. This option provides clarity and control over how data is accessed within your templates, improving readability and maintainability.</p>"},{"location":"Features/Features/#-w-rm-whitespace","title":"-w / --rm-whitespace","text":"<p>The <code>-w</code> or <code>--rm-whitespace</code> argument instructs EJS to remove all safe-to-remove whitespace from the rendered output, including leading and trailing whitespace around template tags. This can lead to smaller file sizes and cleaner output, especially for production environments.</p>"},{"location":"Features/Features/#-d-debug","title":"-d / --debug","text":"<p>Using <code>-d</code> or <code>--debug</code> outputs the generated function body to the console. This feature is invaluable for debugging complex templates, as it allows developers to inspect the compiled JavaScript produced by EJS from their templates.</p>"},{"location":"Features/Features/#-h-help","title":"-h / --help","text":"<p>The <code>-h</code> or <code>--help</code> option displays a help message summarizing the available commands and options in the EJS CLI. This is a quick way to get an overview of the CLI's capabilities or to remind yourself of the syntax for less frequently used options.</p>"},{"location":"Features/Features/#-vv-version","title":"-V/v / --version","text":"<p>Finally, <code>-V</code> or <code>--version</code> displays the currently installed version of EJS. This can be useful for troubleshooting, ensuring compatibility, or simply checking if an update is available.</p> <p>Success</p> <p> By leveraging these features, you can create powerful, flexible, and secure templates with EJS. Whether you're building a small project or a large web application, EJS offers the tools needed to efficiently generate dynamic HTML content.</p> <p>Great job \ud83e\udd17.</p>"},{"location":"Getting%20Started/getStarted/","title":"What is EJS?","text":"<p>Embedded JavaScript, or EJS, is a simple and direct templating language that enables JavaScript to generate HTML. It's frequently used in Express.js, a Node.js framework for creating web applications, but it can also be used in other JavaScript environments.</p> <p>EJS is designed to generate HTML content with embedded JavaScript, primarily on the server. It is used in server-side rendering to produce web pages dynamically, allowing for the creation of web pages with content that can change depending on user actions, server state, or other variables.</p> <p>We aims to provide clear context and prerequisites for new users approaching EJS, laying out the groundwork necessary for successful application and further exploration of the templating engine's capabilities.</p>"},{"location":"Getting%20Started/getStarted/#prerequisite","title":"Prerequisite","text":"<ol> <li> <p>Node.JS     Make sure you installed Node JS on your local machine in order to write JavaScript    The link is provided here:    https://nodejs.org/en</p> </li> <li> <p>After you download the latest version of Node, you can test the JavaScript that you wrote is correctly running in the terminal by typing</p> </li> <li> <p>Text Editor    Use any text editor or (integrated development environment) IDE of your choice for writing code. Popular options include VSCode, Sublime Text, Atom, etc.</p> </li> </ol>"},{"location":"Getting%20Started/getStarted/#installation-of-ejs","title":"Installation of EJS","text":"<p>To install EJS, use npm (node package manager) with the following command in your project directory:</p> <p><code>npm install ejs</code></p>"},{"location":"Getting%20Started/getStarted/#basic-syntax","title":"Basic Syntax","text":"<p>EJS tags include:</p> <p><code>&lt;%</code>: 'Scriptlet' tag, for control-flow, no output <code>&lt;%_</code>: \u2018Whitespace Slurping\u2019 Scriptlet tag, strips all whitespace before it <code>&lt;%=</code>: Outputs the value into the template (HTML escaped) <code>&lt;%-</code>: Outputs the unescaped value into the template (make sure to only use this with content that is coming from the dev, instead of the user) <code>&lt;%#</code>: Comment tag, no execution, no output <code>&lt;%%</code>: Outputs a literal <code>&lt;%</code> <code>%&gt;</code>: Plain ending tag <code>-%&gt;</code>: Trim-mode ('newline slurp') tag, trims following newline <code>_%&gt;</code>: \u2018Whitespace Slurping\u2019 ending tag, removes all whitespace after it</p> <p>Info</p> <p>for more in-depth information, please read here</p>"},{"location":"Getting%20Started/getStarted/#writing-ejs-templates","title":"Writing EJS Templates","text":"<p>Since EJS templates are HTML files with embedded JavaScript code, creating a <code>.ejs</code> files is very similar to creating a HTML file.</p> <p>For example, views/index.ejs:</p> <pre><code>&lt;!DOCTYPE html&gt;\n&lt;html lang=\"en\"&gt;\n  &lt;head&gt;\n    &lt;meta charset=\"UTF-8\" /&gt;\n    &lt;title&gt;Title&lt;/title&gt;\n  &lt;/head&gt;\n  &lt;body&gt;\n    &lt;h1&gt;Welcome to EJS, &lt;%= user.name %&gt;&lt;/h1&gt;\n  &lt;/body&gt;\n&lt;/html&gt;\n</code></pre> <p>Info</p> <p>JavaScript: assuming you have your express.js set up, we have also set up a more in-depth instruction here</p> <pre><code>app.get(\"/\", (req, res) =&gt; {\n  res.render(\"index\", { user: { name: \"John Doe\" } });\n});\n</code></pre> <p>The HTML snippet shows the usage of EJS syntax that inputs the variable which you passed from JavaScript. Notice on line 2 of the JavaScript snippet, we passed in the user object with the name object in the second parameter, so when we put in to ejs file, <code>Welcome to EJS, John Doe</code> will be rendered on the page.</p>"},{"location":"Glossary/glossary/","title":"Glossary","text":"Term Definition EJS (Embedded JavaScript Templates) A templating engine that allows developers to generate HTML markup with plain JavaScript. Templating Engine Software designed to combine templates with a data model to produce result documents. Dynamic Websites Websites that display different content and provide user interaction, as opposed to static websites where content is fixed. Rendering Process The process of converting website code into a visual display on the user's screen. Template Caching A method to store templates in memory after their first render to speed up subsequent renders by avoiding recompilation. Delimiters Characters or sequences of characters used to mark the beginning and end of a block of code or data. Client-Side Rendering Rendering web pages directly in the browser using JavaScript, as opposed to server-side rendering where pages are pre-rendered on the server. Whitespace Any character or series of characters that represent horizontal or vertical space in typography. In programming, it's often used to separate tokens in source code. Compiled Functions In the context of templating engines, these are functions generated from templates, ready to be executed to produce output. DRY Principles (Don't Repeat Yourself) A principle aimed at reducing repetition of software patterns, replacing it with abstractions or using data normalization to avoid redundancy. Manageability The ease with which a software system can be managed in terms of correctness, control, and optimization. Subtemplates Template files that are included within another template, often used for repeating layout components such as headers and footers. Syntax The set of rules that define the combinations of symbols that are considered to be correctly structured programs or documents in a language. Debugging The process of identifying and removing errors from computer software or hardware. Control Flow The order in which individual statements, instructions, or function calls of an imperative program are executed or evaluated. XSS Attacks (Cross-Site Scripting) A type of security vulnerability typically found in web applications, allowing attackers to inject client-side scripts into web pages viewed by other users. HTML Content The content of a webpage, defined using HTML (HyperText Markup Language), which structures the web page and its content."},{"location":"Tags/tags/","title":"Tags","text":"<p>EJS tags are special markers within EJS (Embedded JavaScript Templates) that signal to the EJS engine where JavaScript code is embedded within an HTML file. </p> <p>These tags allow you to inject data, execute JavaScript code, control flow within your templates (such as loops and conditionals), and manage whitespace. </p> <p>Understanding EJS tags is crucial for creating dynamic web pages that can display content based on user interaction, server data, or any logic defined in your JavaScript code. Here's a quick overview of the primary types of EJS tags and what they do:</p>"},{"location":"Tags/tags/#scriptlet-tag","title":"Scriptlet Tag","text":"<p>The Scriptlet tag <code>&lt;% %&gt;</code> is used for embedding any JavaScript code in the template that doesn't produce output in the final HTML. This can include control flow statements, variable declarations, or any logic necessary to prepare the data for display. <pre><code>&lt;%\n  let greeting = 'Hello';   \n  let name = 'World';\n%&gt;\n</code></pre></p>"},{"location":"Tags/tags/#whitespace-slurping-scriptlet-tag","title":"Whitespace Slurping Scriptlet Tag","text":"<p>The Whitespace Slurping Scriptlet tag <code>&lt;%_ _%&gt;</code> allows you to include JavaScript logic in your template while also removing the whitespace before it. It's useful for controlling the amount of whitespace in the rendered output for a cleaner look. <pre><code>&lt;%_ let greeting = 'Hello'; _%&gt;\n&lt;%_ let name = 'World'; _%&gt;\n</code></pre></p>"},{"location":"Tags/tags/#outputs-the-value-html-escaped","title":"Outputs the Value (HTML Escaped)","text":"<p>The <code>&lt;%=</code> tag outputs the value of a JavaScript expression within the template, escaping any HTML to prevent XSS attacks. This is used to safely render user-generated content or any data that may include characters interpreted as HTML.</p> <pre><code>&lt;p&gt;&lt;%= greeting %&gt; &lt;%= name %&gt;!&lt;/p&gt;\n</code></pre>"},{"location":"Tags/tags/#outputs-the-unescaped-value","title":"Outputs the Unescaped Value","text":"<p>The <code>&lt;%-</code> tag outputs the unescaped value into the template. It should be used when you're confident that the content does not pose a risk of XSS attacks, such as when displaying content that includes HTML tags which are part of the design. <pre><code>&lt;p&gt;&lt;%- someHtmlContent %&gt;&lt;/p&gt;\n</code></pre></p>"},{"location":"Tags/tags/#comment-tag","title":"Comment Tag","text":"<p>The Comment tag <code>&lt;%# %&gt;</code> lets you add comments within your EJS templates. These comments do not execute and are not included in the final HTML output. It's useful for leaving notes or commenting out parts of the template during development.</p> <pre><code>&lt;%# This is a comment and won't be rendered in the output %&gt;\n</code></pre>"},{"location":"Tags/tags/#outputs-a-literal","title":"Outputs a Literal '&lt;%'","text":"<p>The <code>&lt;%%</code> tag outputs a literal <code>&lt;%</code> in the template. This can be useful when you need to display the tag itself as part of the webpage, such as in documentation or examples. <pre><code>&lt;%% This will output &lt;% in the HTML %&gt;\n</code></pre></p>"},{"location":"Tags/tags/#plain-ending-tag","title":"Plain Ending Tag","text":"<p>The <code>%&gt;</code> tag is used to close any of the opening EJS tags. It signifies the end of JavaScript code or control flow statements within the template. <pre><code>&lt;%\n  let greeting = \"Hello, World!\";\n%&gt;\n</code></pre></p>"},{"location":"Tags/tags/#trim-mode-newline-slurp-tag","title":"Trim-mode ('newline slurp') Tag","text":"<p>The <code>-%&gt;</code> tag trims the newline character following it in the template, which helps control the whitespace in the rendered output. It's used at the end of a scriptlet t o remove the line break that follows it. <pre><code>&lt;%\n  let greeting = 'Hello';\n-%&gt;\n</code></pre></p>"},{"location":"Tags/tags/#whitespace-slurping-ending-tag","title":"Whitespace Slurping Ending Tag","text":"<p>The <code>_%&gt;</code> tag removes all trailing whitespace after it, similar to the opening tag but used at the end. It's useful for minimizing the amount of unnecessary whitespace in the final output. <pre><code>&lt;%_ let greeting = 'Hello'; _%&gt;\n</code></pre></p>"},{"location":"Tags/tags/#conclusion","title":"Conclusion","text":"<p>By combining these tags in various ways, you can create templates that are both dynamic and secure, rendering content based on data and logic while keeping your HTML clean and organized. </p> <p>Congratulations! \ud83c\udf89 You have learnt all the tags required for you to use ejs effectively.</p>"},{"location":"troubleshooting/troubleshooting/","title":"Introduction","text":"<p>This report provides a systematic approach to diagnose and troubleshoot common issues encountered when working with EJS templates in a web application.</p>"},{"location":"troubleshooting/troubleshooting/#common-issues","title":"Common Issues","text":"<p>1. Template Not Found</p> <p>Symptoms: Error: Could not find the include file</p> <p>Potential Causes:</p> <ul> <li>Incorrect path to the EJS file.</li> <li>File name typo or wrong file extension.</li> </ul> <p>Resolution Steps:</p> <p>Verify the path and file name in the include statement. Check that the file exists in the specified directory.</p> <p>2. Syntax Errors in EJS</p> <p>Symptoms: Syntax-related error messages such as SyntaxError: missing <code>)</code> after argument list.</p> <p>Potential Causes:</p> <ul> <li>Typos or errors in EJS tags.</li> <li>Incorrect JavaScript syntax within EJS tags.</li> </ul> <p>Resolution Steps:</p> <ul> <li>Carefully review the EJS syntax in the template.</li> <li>Ensure all opening <code>&lt;%</code> tags have corresponding closing <code>%&gt;</code> tags.</li> </ul> <p>3. Data Not Rendered</p> <p>Symptoms: Variables not displaying data or rendering as undefined.</p> <p>Potential Causes:</p> <ul> <li>Data not passed correctly to the template.</li> <li>Variables are not properly referenced in the EJS tags.</li> </ul> <p>Resolution Steps:</p> <p>Double-check the data passed into the render function. Ensure variables are correctly referenced using <code>&lt;%= variableName %&gt;</code> syntax.</p> <p>4. EJS Compilation Errors</p> <p>Symptoms: Errors related to EJS compilation such as Unexpected token.</p> <p>Potential Causes:</p> <ul> <li>JavaScript expressions in EJS tags are incorrect.</li> <li>Closing tags might be missing for control structures (if, for, etc.).</li> </ul> <p>Resolution Steps: Look for any typos or syntax errors within scriptlet tags <code>&lt;% %&gt;</code>.</p> <p>5. Performance Issues</p> <p>Symptoms: Slow rendering of EJS templates.</p> <p>Potential Causes:</p> <ul> <li>Complex logic within the templates.</li> <li>Large datasets being processed in the template.</li> </ul> <p>Resolution Steps:</p> <p>Move complex logic to server-side scripts before rendering. Limit the amount of data passed to the template and use pagination.</p> <p>6. EJS Layout Issues</p> <p>Symptoms: Layout components such as headers or footers not appearing correctly.</p> <p>Potential Causes:</p> <ul> <li>Layout files are not correctly included or referenced.</li> <li>Incorrect usage of partials or blocks.</li> </ul> <p>Resolution Steps: Ensure layout files are properly linked with <code>&lt;%- include('layoutFile') %&gt;</code>.</p>"},{"location":"troubleshooting/troubleshooting/#tools-and-techniques","title":"Tools and Techniques","text":"<p>EJS Lint:</p> <p>Use EJS-Lint to detect syntax errors in EJS templates. EJS-Lint replaces everything outside a scriptlet tag with whitespace (to retain line &amp; column numbers) and then runs the resulting (hopefully) valid JS through node-syntax-error to check for errors. You can read more in their documentation here.</p> <p>Simplify Templates:</p> <p>Break down complex templates into smaller components.</p>"},{"location":"troubleshooting/troubleshooting/#conclusion","title":"Conclusion","text":"<p>EJS is a powerful templating engine that enables dynamic content rendering on web pages. However, like any technology, it can encounter issues that require systematic troubleshooting. By following the steps outlined in this report, developers can identify and resolve common EJS issues effectively.</p>"}]}